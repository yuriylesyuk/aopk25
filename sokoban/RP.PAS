program Russian__Soko_ban;

        (*======================================== 02/15/91 06:36pm ===*)
        (*                                                             *)
        (*      реализация игрушки Soko-ban преследует учебные         *)
        (*         цели и акцентирует внимание на критичных            *)
        (*           к процессу программирования местах                *)
        (*                                                             *)
        (*                                                             *)
        (*      ------ версия "З н а н и е  -  с и л а" ------         *)
        (*                                                             *)
        (*================================= (c) Insight corp., 1991 ===*)

uses    crt;

(*============================================ определение констант ===*)

const   F_key = 256;  (* смещение для распознавания управляющих        *)
                      (* клавиш                                        *)

(*----------------------------------------- коды управляющих клавиш ---*)
        F_esc = 27;
        F_restart = 32;  (* фактически - код пробела, но для нас он игра-
                         ет роль клавиши, сбрасывающей лабиринт в началь-
                         ное состояние                                 *)
        F_Left  = F_key + $4b;
        F_Right = F_key + $4d;
        F_Up    = F_key + $48;
        F_Down  = F_key + $50;

(*---------- константы, служащие масками при работе с массивом игры ---*)

        C_ctrl_bit = $80;
        C_bit_mask = $7f;

(*---------------------------константы, задающие кодировку спрайтов ---*)
	(* обратим внимание на тот факт, что спрайты с индексом b      *)
	(* представляют собой код, смещенный на С_ctrl_bit, что        *)
	(* позволяет легко определять поле, в котором находится 'точка'*)
	(* - место, предназначенное для заталкивания туда ящиков       *)

(* свободное для движения простраство                                  +)
	( кстати, места под точками с точки зрения данного выражения   +)
	являются свободными для движения)                              *)

	S_free_place = 0;      Sb_free_place = C_ctrl_bit + S_free_place;
(* фигурка двигателя (объекта, который двигает ящики)                  *)
	S_man = 1;             Sb_man = C_ctrl_bit + S_man;
(* стена лабиринта                                                     *)
	S_wall = 9;            Sb_wall = C_ctrl_bit + S_wall;
(* код объекта передвижения - ящика                                    *)
	S_box = 4;             Sb_box = C_ctrl_bit + S_box;

(*=====================================================================*)

var     game_field: array [1..20, 1..30] of integer; (* массив пред-   *)
                      (* ставляет собой эквивалент изображения на      *)
                      (* экране, но в кодах, что позволяет функции     *)
                      (* moving осуществлять проверку корректности     *)
                      (* перемещения по лабиринту                      *)

        man_X,        (* пара целых представляет собой текущие коор-   *)
	man_Y,        (* динаты двигателя                              *)

        score_all,    (* общее количество мест для ящиков              *)
        score_new,    (* текущее количество ящиков, уложенных на место *)

        kbrd_key:     (* переменная - код следующего введенного        *)
        integer;      (* с клавиатуры символа                          *)

(*==================== системная функция ввода символа с клавиатуры ===*)

function getkey: integer;
        (*-------------------------------------------------------------*)
	(* функция возвращает следующий введенный с клавиатуры символ  *)
        (*                                                             *)
        (* если на клавиатуре был введен управляюший символ            *)
        (* признак - первый байт равен 00                              *)
        (* (вверх-вниз-влево-вправо), то код смещается на величину     *)
        (* F_key                                                       *)
        (*-------------------------------------------------------------*)
var  next_char : char;
begin
     next_char := readkey;
     if( next_char = chr( 00 ) )
     then
          getkey := F_key + ord( readkey )
     else
          getkey := ord( next_char )
end;

(*=====================функция выводит на экран изображение спрайта ===*)

procedure sprite_out( sprite_type: integer );
        (*-------------------------------------------------------------*)
        (* благодаря тому, что вся программа пользуется для вывода     *)
        (* спрайта на экран этой функцией, здесь                       *)
        (* локализуется информация о внешнем виде спрайта,             *)
        (* его цвете, что соответственно, облегчает задачу             *)
        (* проведения изменений в игрушке                              *)
        (*-------------------------------------------------------------*)
begin
     case sprite_type of
          S_free_place: write( '  ' );
          Sb_free_place: write( '. ');
          S_man,
          Sb_man     : write( '><' );
          S_wall,
          Sb_wall : write( chr(178)+chr(178) );
        (*-------------------------------------------------------------*
	 | интерес представляет тот факт, что по кодам S_man и  Sb_man |
	 | выводится один и тот же рисунок спрайта, а по кодам S_box и |
	 | Sb_box - разные, что дает возможность автоматически выводить|
	 | на экран правильную картинку для ящика (незакрашенный, если |
	 | на пустом поле и закрашенный, если на поле, предназначенном |
	 | ящика) и двигателя ( одну и ту же картинку и на пустом поле |
	 | и на поле для ящика                                         |
         *-------------------------------------------------------------*)
          S_box : write( '<>' );
          Sb_box : write( chr(17)+chr(16) );
     end;
end;

(*=====================================================================*)

procedure sprite_show( sprite_x, sprite_y,
                       sprite_type: integer );
        (*-------------------------------------------------------------*)
        (* процедура обеспечивает логический вывод графического образа *)
        (* за спрайта в пределах всех программы, здесь же происходит   *)
        (* коррекция содержимого массива game_field[];                 *)
        (*                                                             *)
        (* в данной процедуре поддерживается ведение счетчика игры     *)
        (*-------------------------------------------------------------*)

begin
     (* проверка необходимости корректировать счетчик очков *)
     if( game_field[ sprite_x, sprite_y ] = Sb_box )
     then 
          if( sprite_type <> S_box )
          then (* если по координате, на которой только что стоял ящик,
		 пишется не-ящик, уменьшить счетчик количества поставленных
		 на место ящиков                                         *)
					     score_new := score_new - 1;
     if( (game_field[ sprite_x, sprite_y ] and C_ctrl_bit ) <> 0 )
     then
          if( sprite_type = S_box )
          then (* если по координате, на которой должен стоять ящик,
		 пишется код ящика, увеличить счетчик количества постав-
		 ленных на место ящиков                                  *)
                 score_new := score_new + 1 ;

     game_field[ sprite_x, sprite_y ] :=
         (game_field[ sprite_x, sprite_y ] and C_ctrl_bit )
              or ( sprite_type ) ;
     gotoXY( sprite_y*2, sprite_x );
     sprite_out( game_field[ sprite_x, sprite_y ] )
end;


(*=====================================================================*)

procedure maze_init;
        (*-------------------------------------------------------------*)
        (* процедура инициализирует массив game_field[], содержащий    *)
        (* поле лабиринта, ящики, места для них                        *)
        (* а также устанавливает счетчики игрушки: общее количество    *)
        (* мест для установки ящиков score_all, количество уже         *)
        (* установленных на место ящиков score_new                     *)
        (*-------------------------------------------------------------*)

var i, j: integer;

    maze : array [ 1..20 ] of string[ 31 ];

begin
(*                     0         1         2         3  *)
(*                     1234567890123456789012345678901  *)
        maze[ 01 ] := '000000000000000000000000000000';
        maze[ 02 ] := '000000099999000000000000000000';
        maze[ 03 ] := '000000090009000000000000000000';
        maze[ 04 ] := '000000094009000000000000000000';
      	maze[ 05 ] := '000009990049990000000000000000';
        maze[ 06 ] := '000009004004090000000000000000';
        maze[ 07 ] := '000999090999090000099999900000';
        maze[ 08 ] := '000900090999099999990033900000';
        maze[ 09 ] := '000904004000000000000033900000';
        maze[ 10 ] := '000999990999909199990033900000';
        maze[ 11 ] := '000000090000009990099999900000';
        maze[ 12 ] := '000000099999999000000000000000';
        maze[ 13 ] := '000000000000000000000000000000';

(*---------------- начальная инициализация массива & очистка экрана ---*)

    for i:=1 to 20 do
        for j:=1 to 30 do
            begin
            game_field[ i,j ] := 0 ;
            sprite_show( i,j, S_free_place );
            end;

(*-------------------------------------------- считывание лабиринта ---*)

    score_all := 0;
    score_new := 0;

    for i:=1 to 13 do
        for j:=1 to 30 do
            case maze[ i ][ j ] of
               '0': sprite_show( i, j, S_free_place );
               '9': sprite_show( i, j, S_wall );
               '4': sprite_show( i, j, S_box );
               '3': begin
                    sprite_show( i, j, Sb_free_place );
                    score_all := score_all + 1
                    end;
               '7': begin
                    sprite_show( i, j, Sb_box );
                    score_all := score_all + 1;
                    score_new := score_new + 1
                    end;
               '1': begin
                    sprite_show( i, j, S_man );
                    man_X := i;
                    man_Y := j;
                    end;
               '2': begin
                    sprite_show( i, j, Sb_man );
                    man_X := i;
                    man_Y := j;
                    score_all := score_all + 1
                    end;
               else
                    sprite_show( i, j, S_free_place );
            end
end;

(*=====================================================================*)

procedure moving( dlt_x, dlt_Y : integer );
        (*-------------------------------------------------------------*)
        (* процедура осуществляет отработку движения в заданном направ-*)
        (* лении                                                       *)
        (*                                                             *)
        (* направление задается парой смещений dlt_x, dlt_y            *)
        (*                                                             *)
        (* так, например, если dlt_x = 0, a dlt_y = + 1, то это означа-*)
        (* ет, что отрабатывается движение           ^                 *)
        (* в направлении вниз, то есть,              | ( 0, - 1 )      *)
        (* согласно следующей системе                |                 *)
        (* координат:                         <-- -- + -- -->          *)
        (*                               ( - 1, 0 )  |     ( + 1, 0 )  *)
        (*                                           |                 *)
        (*                                           V ( 0, + 1 )      *)
        (*-------------------------------------------------------------*)

begin
		 (* свободно ли следующее поле? *)

		 if((game_field[man_X+dlt_X,man_Y+dlt_Y])and C_bit_mask = S_free_place)
     then begin
          (* перемещение двигателя на следующее поле *)
          man_X := man_X + dlt_X;
          man_Y := man_Y + dlt_Y
          end
     else (* проверим, может это ящик *)
        if( game_field[man_X+dlt_X, man_Y+dlt_Y]and C_bit_mask = S_box )
        then
            (* а свободно ли поле за ящиком? *)
            if( game_field[man_X+dlt_X*2, man_Y+dlt_Y*2]and C_bit_mask
                           = S_free_place )
           then
           begin
             (* переместим ящик и двигателя на поле в данном направлении *)
             sprite_show( man_X+dlt_X, man_Y+dlt_Y, S_free_place );
             sprite_show( man_X+dlt_X*2, man_Y+dlt_Y*2, S_box );
             man_X := man_X + dlt_X;
             man_Y := man_Y + dlt_Y
           end;
end;

(*=====================================================================*)

procedure game_round;

        (*-------------------------------------------------------------*)
        (*                                                             *)
        (*                основной цикл игрушки                        *)
        (*                                                             *)
        (*-------------------------------------------------------------*)

begin
  repeat

		(* выводим двигателя по текущей координате *)
    sprite_show( man_X, man_Y, S_man );

		(* вводим команду с клавиатуры *)
    kbrd_key := getkey;

		(* стираем двигателя по текущей координате *)
    sprite_show( man_X, man_Y, S_free_place );

		(* отрабатываем управляющую клавишу *)
    case kbrd_key of
         F_Left : moving( 0, -1 );

         F_Right: moving( 0, +1 );

         F_Up   : moving( -1, 0 );

         F_Down : moving( +1, 0 );

    end;

	(* и так до тех пор, пока либо не установим все ящики на месте, либо 
	не введем код F_esc, либо код F_restart                           *)

  until(  (score_new = score_all) (* все ящики на местах? *)
	     or (kbrd_key = F_esc) or (kbrd_key = F_restart) );
end;

(*=====================================================================*)

begin
        (*-------------------------------------------------------------*)
        (*                                                             *)
        (*                                                             *)
        (*                                                             *)
        (*                                                             *)
        (*                                                             *)
        (*                                                             *)
        (*-------------------------------------------------------------*)

(*---------------------------------------------------------------------*)

    maze_init;

    game_round;

(*------------------------------------------------ раздача слоников ---*)

    if( score_new = score_all )
    then
        begin
        gotoXY( 12, 20 );
        write( '*** маладец! ***');
        kbrd_key := getkey;
        end
    else
        begin
        gotoXY( 12, 20 );
        write( '*** слаб-ба-к! ***' );
        kbrd_key := getkey;
        end
(*--------------------------------------------------------------------*)

end.
